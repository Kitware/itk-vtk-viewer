import registerWebworker from"webworker-promise/lib/register.js";import runPipelineEmscripten from"../pipeline/internal/runPipelineEmscripten.js";import IOTypes from"../core/IOTypes.js";import getTransferable from"../core/getTransferable.js";import InterfaceTypes from"../core/InterfaceTypes.js";import meshTransferables from"../core/internal/meshTransferables.js";import polyDataTransferables from"../core/internal/polyDataTransferables.js";async function runPipeline(e,r,s,a){const t=runPipelineEmscripten(e,r,s,a),n=[];return t.outputs&&t.outputs.forEach((function(e){if(e.type===InterfaceTypes.BinaryStream||e.type===InterfaceTypes.BinaryFile){const r=e.data,s=getTransferable(r);s&&n.push(s)}else if(e.type===InterfaceTypes.Image){const r=e.data;let s=getTransferable(r.data);s&&n.push(s),s=getTransferable(r.direction),s&&n.push(s)}else if(e.type===InterfaceTypes.Mesh){const r=e.data,s=meshTransferables(r);n.push(...s)}else if(e.type===InterfaceTypes.PolyData){const r=e.data,s=polyDataTransferables(r);n.push(...s)}else if(e.type===IOTypes.Binary){const r=e.data,s=getTransferable(r);s&&n.push(s)}else if(e.type===IOTypes.Image){const r=e.data;let s=getTransferable(r.data);s&&n.push(s),s=getTransferable(r.direction),s&&n.push(s)}else if(e.type===IOTypes.Mesh){const r=e.data;if(r.points){const e=getTransferable(r.points);e&&n.push(e)}if(r.pointData){const e=getTransferable(r.pointData);e&&n.push(e)}if(r.cells){const e=getTransferable(r.cells);e&&n.push(e)}if(r.cellData){const e=getTransferable(r.cellData);e&&n.push(e)}}})),new registerWebworker.TransferableResponse(t,n)}export default runPipeline;