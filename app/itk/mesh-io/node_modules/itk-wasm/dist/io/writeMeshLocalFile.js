import path from"path";import mime from"mime-types";import mimeToIO from"./internal/MimeToMeshIO.js";import getFileExtension from"./getFileExtension.js";import extensionToIO from"./extensionToMeshIO.js";import MeshIOIndex from"./internal/MeshIOIndex.js";import loadEmscriptenModule from"../core/internal/loadEmscriptenModuleNode.js";import runPipelineEmscripten from"../pipeline/internal/runPipelineEmscripten.js";import findLocalMeshIOPath from"./internal/findLocalMeshIOPath.js";import InterfaceTypes from"../core/InterfaceTypes.js";async function writeMeshLocalFile(e,n,i){if("useCompression"in e||"binaryFileType"in e)throw new Error("options are now in the last argument position in itk-wasm");const o=findLocalMeshIOPath(),t=path.resolve(n),r=mime.lookup(t),s=getFileExtension(t),l=["0",t,"--memory-io","--quiet"];!0===(null==i?void 0:i.useCompression)&&l.push("--use-compression"),!0===(null==i?void 0:i.binaryFileType)&&l.push("--binary-file-type");const m=[],a=[{type:InterfaceTypes.Mesh,data:e}];let p=null;if(!1!==r&&mimeToIO.has(r))p=mimeToIO.get(r);else if(extensionToIO.has(s))p=extensionToIO.get(s);else for(let e=0;e<MeshIOIndex.length;++e){const n=path.join(o,MeshIOIndex[e]+"WriteMesh.js"),i=await loadEmscriptenModule(n),r=i.mountContainingDir(t),{returnValue:s}=runPipelineEmscripten(i,l,m,a);if(i.unmountContainingDir(r),0===s)return null}if(null===p)throw Error("Could not find IO for: "+t);const u=path.join(o,p+"WriteMesh.js"),h=await loadEmscriptenModule(u),f=h.mountContainingDir(t);return runPipelineEmscripten(h,l,m,a),h.unmountContainingDir(f),null}export default writeMeshLocalFile;