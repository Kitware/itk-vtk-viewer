"use strict";const fs=require("../fs"),path=require("path"),util=require("util");function getStats(t,r,e){const n=e.dereference?t=>fs.stat(t,{bigint:!0}):t=>fs.lstat(t,{bigint:!0});return Promise.all([n(t),n(r).catch((t=>{if("ENOENT"===t.code)return null;throw t}))]).then((([t,r])=>({srcStat:t,destStat:r})))}function getStatsSync(t,r,e){let n;const a=e.dereference?t=>fs.statSync(t,{bigint:!0}):t=>fs.lstatSync(t,{bigint:!0}),i=a(t);try{n=a(r)}catch(t){if("ENOENT"===t.code)return{srcStat:i,destStat:null};throw t}return{srcStat:i,destStat:n}}function checkPaths(t,r,e,n,a){util.callbackify(getStats)(t,r,n,((n,i)=>{if(n)return a(n);const{srcStat:c,destStat:s}=i;if(s){if(areIdentical(c,s)){const n=path.basename(t),i=path.basename(r);return"move"===e&&n!==i&&n.toLowerCase()===i.toLowerCase()?a(null,{srcStat:c,destStat:s,isChangingCase:!0}):a(new Error("Source and destination must not be the same."))}if(c.isDirectory()&&!s.isDirectory())return a(new Error(`Cannot overwrite non-directory '${r}' with directory '${t}'.`));if(!c.isDirectory()&&s.isDirectory())return a(new Error(`Cannot overwrite directory '${r}' with non-directory '${t}'.`))}return c.isDirectory()&&isSrcSubdir(t,r)?a(new Error(errMsg(t,r,e))):a(null,{srcStat:c,destStat:s})}))}function checkPathsSync(t,r,e,n){const{srcStat:a,destStat:i}=getStatsSync(t,r,n);if(i){if(areIdentical(a,i)){const n=path.basename(t),c=path.basename(r);if("move"===e&&n!==c&&n.toLowerCase()===c.toLowerCase())return{srcStat:a,destStat:i,isChangingCase:!0};throw new Error("Source and destination must not be the same.")}if(a.isDirectory()&&!i.isDirectory())throw new Error(`Cannot overwrite non-directory '${r}' with directory '${t}'.`);if(!a.isDirectory()&&i.isDirectory())throw new Error(`Cannot overwrite directory '${r}' with non-directory '${t}'.`)}if(a.isDirectory()&&isSrcSubdir(t,r))throw new Error(errMsg(t,r,e));return{srcStat:a,destStat:i}}function checkParentPaths(t,r,e,n,a){const i=path.resolve(path.dirname(t)),c=path.resolve(path.dirname(e));if(c===i||c===path.parse(c).root)return a();fs.stat(c,{bigint:!0},((i,s)=>i?"ENOENT"===i.code?a():a(i):areIdentical(r,s)?a(new Error(errMsg(t,e,n))):checkParentPaths(t,r,c,n,a)))}function checkParentPathsSync(t,r,e,n){const a=path.resolve(path.dirname(t)),i=path.resolve(path.dirname(e));if(i===a||i===path.parse(i).root)return;let c;try{c=fs.statSync(i,{bigint:!0})}catch(t){if("ENOENT"===t.code)return;throw t}if(areIdentical(r,c))throw new Error(errMsg(t,e,n));return checkParentPathsSync(t,r,i,n)}function areIdentical(t,r){return r.ino&&r.dev&&r.ino===t.ino&&r.dev===t.dev}function isSrcSubdir(t,r){const e=path.resolve(t).split(path.sep).filter((t=>t)),n=path.resolve(r).split(path.sep).filter((t=>t));return e.reduce(((t,r,e)=>t&&n[e]===r),!0)}function errMsg(t,r,e){return`Cannot ${e} '${t}' to a subdirectory of itself, '${r}'.`}module.exports={checkPaths,checkPathsSync,checkParentPaths,checkParentPathsSync,isSrcSubdir,areIdentical};